##
##
## Apache License
## Version 2.0, January 2004
## http://www.apache.org/licenses/
##
## TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
##
## 1. Definitions.
##
## "License" shall mean the terms and conditions for use, reproduction,
## and distribution as defined by Sections 1 through 9 of this document.
##
## "Licensor" shall mean the copyright owner or entity authorized by
## the copyright owner that is granting the License.
##
## "Legal Entity" shall mean the union of the acting entity and all
## other entities that control, are controlled by, or are under common
## control with that entity. For the purposes of this definition,
## "control" means (i) the power, direct or indirect, to cause the
## direction or management of such entity, whether by contract or
## otherwise, or (ii) ownership of fifty percent (50%) or more of the
## outstanding shares, or (iii) beneficial ownership of such entity.
##
## "You" (or "Your") shall mean an individual or Legal Entity
## exercising permissions granted by this License.
##
## "Source" form shall mean the preferred form for making modifications,
## including but not limited to software source code, documentation
## source, and configuration files.
##
## "Object" form shall mean any form resulting from mechanical
## transformation or translation of a Source form, including but
## not limited to compiled object code, generated documentation,
## and conversions to other media types.
##
## "Work" shall mean the work of authorship, whether in Source or
## Object form, made available under the License, as indicated by a
## copyright notice that is included in or attached to the work
## (an example is provided in the Appendix below).
##
## "Derivative Works" shall mean any work, whether in Source or Object
## form, that is based on (or derived from) the Work and for which the
## editorial revisions, annotations, elaborations, or other modifications
## represent, as a whole, an original work of authorship. For the purposes
## of this License, Derivative Works shall not include works that remain
## separable from, or merely link (or bind by name) to the interfaces of,
## the Work and Derivative Works thereof.
##
## "Contribution" shall mean any work of authorship, including
## the original version of the Work and any modifications or additions
## to that Work or Derivative Works thereof, that is intentionally
## submitted to Licensor for inclusion in the Work by the copyright owner
## or by an individual or Legal Entity authorized to submit on behalf of
## the copyright owner. For the purposes of this definition, "submitted"
## means any form of electronic, verbal, or written communication sent
## to the Licensor or its representatives, including but not limited to
## communication on electronic mailing lists, source code control systems,
## and issue tracking systems that are managed by, or on behalf of, the
## Licensor for the purpose of discussing and improving the Work, but
## excluding communication that is conspicuously marked or otherwise
## designated in writing by the copyright owner as "Not a Contribution."
##
## "Contributor" shall mean Licensor and any individual or Legal Entity
## on behalf of whom a Contribution has been received by Licensor and
## subsequently incorporated within the Work.
##
## 2. Grant of Copyright License. Subject to the terms and conditions of
## this License, each Contributor hereby grants to You a perpetual,
## worldwide, non-exclusive, no-charge, royalty-free, irrevocable
## copyright license to reproduce, prepare Derivative Works of,
## publicly display, publicly perform, sublicense, and distribute the
## Work and such Derivative Works in Source or Object form.
##
## 3. Grant of Patent License. Subject to the terms and conditions of
## this License, each Contributor hereby grants to You a perpetual,
## worldwide, non-exclusive, no-charge, royalty-free, irrevocable
## (except as stated in this section) patent license to make, have made,
## use, offer to sell, sell, import, and otherwise transfer the Work,
## where such license applies only to those patent claims licensable
## by such Contributor that are necessarily infringed by their
## Contribution(s) alone or by combination of their Contribution(s)
## with the Work to which such Contribution(s) was submitted. If You
## institute patent litigation against any entity (including a
## cross-claim or counterclaim in a lawsuit) alleging that the Work
## or a Contribution incorporated within the Work constitutes direct
## or contributory patent infringement, then any patent licenses
## granted to You under this License for that Work shall terminate
## as of the date such litigation is filed.
##
## 4. Redistribution. You may reproduce and distribute copies of the
## Work or Derivative Works thereof in any medium, with or without
## modifications, and in Source or Object form, provided that You
## meet the following conditions:
##
## (a) You must give any other recipients of the Work or
## Derivative Works a copy of this License; and
##
## (b) You must cause any modified files to carry prominent notices
## stating that You changed the files; and
##
## (c) You must retain, in the Source form of any Derivative Works
## that You distribute, all copyright, patent, trademark, and
## attribution notices from the Source form of the Work,
## excluding those notices that do not pertain to any part of
## the Derivative Works; and
##
## (d) If the Work includes a "NOTICE" text file as part of its
## distribution, then any Derivative Works that You distribute must
## include a readable copy of the attribution notices contained
## within such NOTICE file, excluding those notices that do not
## pertain to any part of the Derivative Works, in at least one
## of the following places: within a NOTICE text file distributed
## as part of the Derivative Works; within the Source form or
## documentation, if provided along with the Derivative Works; or,
## within a display generated by the Derivative Works, if and
## wherever such third-party notices normally appear. The contents
## of the NOTICE file are for informational purposes only and
## do not modify the License. You may add Your own attribution
## notices within Derivative Works that You distribute, alongside
## or as an addendum to the NOTICE text from the Work, provided
## that such additional attribution notices cannot be construed
## as modifying the License.
##
## You may add Your own copyright statement to Your modifications and
## may provide additional or different license terms and conditions
## for use, reproduction, or distribution of Your modifications, or
## for any such Derivative Works as a whole, provided Your use,
## reproduction, and distribution of the Work otherwise complies with
## the conditions stated in this License.
##
## 5. Submission of Contributions. Unless You explicitly state otherwise,
## any Contribution intentionally submitted for inclusion in the Work
## by You to the Licensor shall be under the terms and conditions of
## this License, without any additional terms or conditions.
## Notwithstanding the above, nothing herein shall supersede or modify
## the terms of any separate license agreement you may have executed
## with Licensor regarding such Contributions.
##
## 6. Trademarks. This License does not grant permission to use the trade
## names, trademarks, service marks, or product names of the Licensor,
## except as required for reasonable and customary use in describing the
## origin of the Work and reproducing the content of the NOTICE file.
##
## 7. Disclaimer of Warranty. Unless required by applicable law or
## agreed to in writing, Licensor provides the Work (and each
## Contributor provides its Contributions) on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
## implied, including, without limitation, any warranties or conditions
## of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
## PARTICULAR PURPOSE. You are solely responsible for determining the
## appropriateness of using or redistributing the Work and assume any
## risks associated with Your exercise of permissions under this License.
##
## 8. Limitation of Liability. In no event and under no legal theory,
## whether in tort (including negligence), contract, or otherwise,
## unless required by applicable law (such as deliberate and grossly
## negligent acts) or agreed to in writing, shall any Contributor be
## liable to You for damages, including any direct, indirect, special,
## incidental, or consequential damages of any character arising as a
## result of this License or out of the use or inability to use the
## Work (including but not limited to damages for loss of goodwill,
## work stoppage, computer failure or malfunction, or any and all
## other commercial damages or losses), even if such Contributor
## has been advised of the possibility of such damages.
##
## 9. Accepting Warranty or Additional Liability. While redistributing
## the Work or Derivative Works thereof, You may choose to offer,
## and charge a fee for, acceptance of support, warranty, indemnity,
## or other liability obligations and/or rights consistent with this
## License. However, in accepting such obligations, You may act only
## on Your own behalf and on Your sole responsibility, not on behalf
## of any other Contributor, and only if You agree to indemnify,
## defend, and hold each Contributor harmless for any liability
## incurred by, or claims asserted against, such Contributor by reason
## of your accepting any such warranty or additional liability.
##
## END OF TERMS AND CONDITIONS
##
## APPENDIX: How to apply the Apache License to your work.
##
## To apply the Apache License to your work, attach the following
## boilerplate notice, with the fields enclosed by brackets "[]"
## replaced with your own identifying information. (Don't include
## the brackets!) The text should be enclosed in the appropriate
## comment syntax for the file format. We also recommend that a
## file or class name and description of purpose be included on the
## same "printed page" as the copyright notice for easier
## identification within third-party archives.
##
## Copyright [yyyy] [name of copyright owner]
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#-------------------------------------------------------------------------------
# Name: es.py
# Purpose: This file implements fuzzy expert system.
#
# Author: Roman Graf
#
# Created: 19.09.2014
# Copyright: (c) GrafR 2014
# Licence: Apache 2.0
#-------------------------------------------------------------------------------
#!/usr/bin/env python

import os

DEFAULT_FILE_NAME = 'D:\\fuzzy_gui\\matchbox.fcl'
DEFAULT_FILE_NAME_DEF = DEFAULT_FILE_NAME.replace('.fcl','-def.fcl')
OUTPUT_RULE = 0
INPUT_RULE = 1
LINE_WIDTH = 2
X_START = 20
Y_START = 20
ADD_RULE_ID = 0
REMOVE_RULE_ID = 1
RUN_ID = 2
EXPORT_ID = 3
WIDTH = 100
HEIGHT = 20
DX = 20
DY = 40
FONT_SIZE = 10
ID_PLOT = 4

# dialog
ADD_TERM = 1
# the number of terms
TERM_NUMBER = 4
# the number of range input fields
RANGE_NUMBER = TERM_NUMBER*2

try:
    import numpy as N
    import numpy.random as RandomArray
    haveNumpy = True
    #print "Using numpy, version:", N.__version__
except ImportError:
            # numpy isn't there
            haveNumpy = False
            errorText = (
            "The Expert System Tool requires the numpy module, version 1.* \n\n"
            "You can get info about it at:\n"
            "http://numpy.scipy.org/\n\n"
            )

#---------------------------------------------------------------------------

def BuildDrawFrame(): # this gets called when needed, rather than on import
    try:
        from floatcanvas import NavCanvas, FloatCanvas, Resources
    except ImportError: # if it's not there locally, try the wxPython lib.
        from wx.lib.floatcanvas import NavCanvas, FloatCanvas, Resources
    import wx.lib.colourdb
    import time, random
    import wx.lib.dialogs

    class RuleEditDialog(wx.Dialog):
         def __init__(self, parent, id, title):
             wx.Dialog.__init__(self, parent, id, 'Edit rule: ' + title, size=(935,140))

             self.ruleName = title
             self.sizer = wx.FlexGridSizer(cols=4 + RANGE_NUMBER, hgap=6, vgap=6)
             self.terms = [0 for x in xrange(TERM_NUMBER)]
             self.ranges = [[0 for x in xrange(RANGE_NUMBER)] for x in xrange(TERM_NUMBER)]
             self.removeFlags = [0 for x in xrange(TERM_NUMBER)]
             print 'dialog rectangle terms', len(Model.terms)
             termIdx = 0
             for term in Model.terms:
                print 'term name: ', term.rule, 'title: ', title.replace(' ', '_')
                if term.rule == title.replace(' ', '_'):
                    print 'term.range: ', len(term.range_dict)
                    termLabel = wx.StaticText(self, -1, "Term:")
                    self.terms[termIdx] = wx.TextCtrl(self, -1, term.name, size=(175, -1))
                    self.terms[termIdx].SetInsertionPoint(0)
                    rangeLabel = wx.StaticText(self, -1, "Range:")
                    print 'range str: ', term.range_dict
                    range_size = len(term.range_dict)
                    for i, value in enumerate(term.range_dict):
                        #if value is not None:
                        initRange = wx.TextCtrl(self, -1, "kkk" + str(i), size=(6000, -1000))
                        self.ranges[termIdx][i] = initRange
                        print 'added init range: ', self.ranges[termIdx][i].GetValue(), 'termIdx: ', termIdx, 'i: ', i

                    print 'init self.ranges len: ', len(self.ranges[termIdx])
                    for i, value in enumerate(term.range_dict):
                        rangeValue = ""
                        if value is not None:
                            rangeValue = value
                        curRange = wx.TextCtrl(self, -1, rangeValue, size=(60, -1))
                        self.ranges[termIdx][i] = curRange
                        print 'current ranges: ', self.ranges[termIdx][i].GetValue(), 'termIdx: ', termIdx, 'i: ', i

                    print 'range size: ', range_size
                    if range_size < RANGE_NUMBER:
                        count = range_size
                        while (count < RANGE_NUMBER):
                            print 'The count is:', count
                            curRange = wx.TextCtrl(self, -1, "", size=(60, -1))
                            self.ranges[termIdx][count] = curRange
                            print 'place holder ranges: ', self.ranges[termIdx][count].GetValue(), 'termIdx: ', termIdx, 'count: ', count
                            count = count + 1

                    self.removeFlags[termIdx] = wx.CheckBox(self, -1, 'Remove Term', (10, 10))
                    self.removeFlags[termIdx].SetValue(False)
                    wx.EVT_CHECKBOX(self, self.removeFlags[termIdx].GetId(), self.RemoveTerm(termIdx))

                    print 'self.ranges len: ', len(self.ranges[termIdx])
                    self.sizer.AddMany([termLabel, self.terms[termIdx], rangeLabel,
                            self.ranges[termIdx][0], self.ranges[termIdx][1],
                            self.ranges[termIdx][2], self.ranges[termIdx][3],
                            self.ranges[termIdx][4], self.ranges[termIdx][5],
                            self.ranges[termIdx][6], self.ranges[termIdx][7],
                            self.removeFlags[termIdx]])

                    termIdx = termIdx + 1

             okButton = wx.Button(self, wx.ID_OK, "OK")
             self.sizer.Add(okButton)
             cancelButton = wx.Button(self, wx.ID_CANCEL, "Cancel", (50, 50))
             self.sizer.Add(cancelButton)
             plotButton = wx.Button(self, ID_PLOT, "Plot")
             self.sizer.Add(plotButton, 1, wx.EXPAND)
             self.Bind(wx.EVT_BUTTON, self.OnCmdButton, plotButton)

             self.SetSizer(self.sizer)

         def RemoveTerm(self, termIdx):
             if self.removeFlags[termIdx].GetValue():
                 self.SetTitle('checkbox.py')
             else: self.SetTitle('')

         def OnCmdButton(self, event):
            if event.GetId() == ID_PLOT:
                self.showPlot(self.ruleName)

         def showPlot(self, rule):
            import os
            import sys
            import string
            from PIL import Image
            from pylab import plot
            from pylab import title
            from pylab import show
            from pylab import ylabel
            from pylab import xlabel
            from pylab import text
            from pylab import legend
            x = 100
            col_averages = 200
            width = 100
            mean = 50
            left_x = 0
            min_left_rand = 20
            max_left_rand = 80
            right_x = 0
            min_right_rand = 20
            max_right_rand = 80
            FLAG_SIZE = 100
            GAP_RATIO = 2
            idx = 0
            colours = []
            colours.extend('r')
            colours.extend('b')
            colours.extend('g')
            termNames = []
            for term in Model.terms:
                #print 'term name: ', term.rule, 'title: ', rule.replace(' ', '_')
                if term.rule == rule.replace(' ', '_'):
                    print 'plot term size: ', len(term.range_dict)
                    print 'range str: ', term.range_dict
                    x_values = term.range_dict[::2]
                    y_values = term.range_dict[1::2]
                    print 'x_values', x_values, 'y_values', y_values
                    print 'x_max', max(x_values), 'y_max', max(y_values)
                    range_size = len(term.range_dict)
                    # define max on X and on Y
                    max_x = 0
                    max_y = 0

                    termNames.append(term.name)
                    # First term is blue, second term is red, third term is orange
                    # if multiple lines in one term
                    isAddZero = False
                    if len(term.range_dict) > 2 and term.range_dict[1] is not None:
                        for i in range(range_size/2):
                            print 'i plot', i
                            if i < len(term.range_dict)/2 - 1:
                                print 'plot term name', term.name, 'i', i, 'idx', idx, 'x_value1', x_values[i], 'x_value2', x_values[i+1], 'y_value1', y_values[i], 'y_value2', y_values[i+1], 'color', colours[idx]
                                plot([x_values[i],x_values[i+1]],[y_values[i],y_values[i+1]],colours[idx]+'-', label=term.name, linewidth=2)
                    # if flag term
                    else:
                        if term.range_dict[1] is None:
##                            plot([0,FLAG_SIZE*idx],[0,FLAG_SIZE],colours[idx], label=term.name, linewidth=2)
                            print 'plot term name', term.name
                            #if idx == 0:
                            isAddZero = True
                            plot([0,FLAG_SIZE],[term.range_dict[0],term.range_dict[0]],colours[idx]+'-', label=term.name, linewidth=2)
##                            plot([0,FLAG_SIZE*idx],[0,FLAG_SIZE],colours[idx], label=term.name, linewidth=2)
                    idx = idx + 1
##                    plot([0, int(max_x)+1],[0, int(max_y)+1])
            print 'isAddZero', isAddZero
            if isAddZero:
                plot([0,FLAG_SIZE],[0,0],'b-', linewidth=2)

            title('Rule: ' + rule)

            ylabel('Y axis')
            xlabel('X axis ')
            print termNames
            legend( termNames )

            show()

    class Rule(object):

        def __init__(self, name, type):
            super(Rule, self).__init__()

            self.initUI(name, type)

        def initUI(self, name, type):

            self.name = name
            self.type = type
            #self.start = 0
            #self.end = 0

    class Dependency(object):

        def __init__(self, name, dependency_dict):
            super(Dependency, self).__init__()

            self.initUI(name, dependency_dict)

        def initUI(self, name, dependency_dict):

            self.name = name
            self.dependency_dict = dependency_dict

    class Decision(object):

        def __init__(self, name, condition):
            super(Decision, self).__init__()

            self.initUI(name, condition)

        def initUI(self, name, condition):

            self.name = name
            self.condition = condition

    class Term(object):

        def __init__(self, rule, name, range_dict):
            super(Term, self).__init__()

            self.initUI(rule, name, range_dict)

        def initUI(self, rule, name, range_dict):

            self.rule = rule
            self.name = name
            self.range_dict = range_dict

    class Input(object):

        def __init__(self, name, min_range, max_range, weight):
            super(Input, self).__init__()

            self.initUI(name, min_range, max_range, weight)

        def initUI(self, name, min_range, max_range, weight):

            self.name = name
            self.min_range = min_range
            self.max_range = max_range
            self.weight = weight

    class Output(Input):
            pass

    class Model():

        rules = []
        inputs = []
        outputs = []
        exp_values = []
        dependencies = []
        terms = []
        headers = []
        decisions = []
        res_str = ''
        rule_counter = 0
        isRun = False

        def __init__(self):
            super(Model, self).__init__()

            self.initUI()



    class DrawFrame(wx.Frame):

        """
        A frame used for the FloatCanvas Demo

        """


        def __init__(self,parent, id,title,position,size):
            wx.Frame.__init__(self,parent, id,title,position, size)

            self.data = None
            self.filename = DEFAULT_FILE_NAME
            self.dirname = None

            self.data_def = None
            self.filename_def = DEFAULT_FILE_NAME_DEF
            self.dirname_def = None

            ## Set up the MenuBar
            MenuBar = wx.MenuBar()

            file_menu = wx.Menu()
            item = file_menu.Append(-1, "&Close","Close this frame")
            self.Bind(wx.EVT_MENU, self.OnQuit, item)

            menuOpen = file_menu.Append(-1, "&Open"," Open a file to edit")
            self.Bind(wx.EVT_MENU, self.OnOpen, menuOpen)

            showFlcFile = file_menu.Append(wx.ID_OPEN, "&OpenFLC"," Open an FLC file to read")
            self.Bind(wx.EVT_MENU, self.ShowFlcFile, showFlcFile)

            item = file_menu.Append(-1, "&SavePNG","Save the current image as a PNG")
            self.Bind(wx.EVT_MENU, self.OnSavePNG, item)
            MenuBar.Append(file_menu, "&File")

            draw_menu = wx.Menu()

            item = draw_menu.Append(-1, "&Clear","Clear the Canvas")
            self.Bind(wx.EVT_MENU, self.Clear, item)

            MenuBar.Append(draw_menu, "&Tests")

            view_menu = wx.Menu()
            item = view_menu.Append(-1, "Zoom to &Fit","Zoom to fit the window")
            self.Bind(wx.EVT_MENU, self.ZoomToFit, item)
            MenuBar.Append(view_menu, "&View")

            help_menu = wx.Menu()
            item = help_menu.Append(-1, "&About",
                                    "More information About this program")
            self.Bind(wx.EVT_MENU, self.OnAbout, item)
            MenuBar.Append(help_menu, "&Help")

            self.SetMenuBar(MenuBar)

            self.CreateStatusBar()


            self.sizer2 = wx.BoxSizer(wx.HORIZONTAL)
            self.buttons = []
            self.buttons.append(wx.Button(self, ADD_RULE_ID, "Add Rule"))
            self.sizer2.Add(self.buttons[ADD_RULE_ID], 1, wx.EXPAND)
            self.Bind(wx.EVT_BUTTON, self.OnCmdButton, self.buttons[ADD_RULE_ID])
            self.buttons.append(wx.Button(self, REMOVE_RULE_ID, "Remove Rule"))
            self.sizer2.Add(self.buttons[REMOVE_RULE_ID], 1, wx.EXPAND)
            self.Bind(wx.EVT_BUTTON, self.OnCmdButton, self.buttons[REMOVE_RULE_ID])
            self.buttons.append(wx.Button(self, RUN_ID, "Run"))
            self.sizer2.Add(self.buttons[RUN_ID], 1, wx.EXPAND)
            self.Bind(wx.EVT_BUTTON, self.OnCmdButton, self.buttons[RUN_ID])
            self.buttons.append(wx.Button(self, EXPORT_ID, "Export Rule Engine"))
            self.sizer2.Add(self.buttons[EXPORT_ID], 1, wx.EXPAND)
            self.Bind(wx.EVT_BUTTON, self.OnCmdButton, self.buttons[EXPORT_ID])

            # Add the Canvas
            NC = NavCanvas.NavCanvas(self,
                                     Debug = 0,
                                     BackgroundColor = "DARK SLATE BLUE")

            self.Canvas = NC.Canvas # reference the contained FloatCanvas

            self.MsgWindow = wx.TextCtrl(self, wx.ID_ANY,
                                         "Look Here for output from events\n",
                                         style = (wx.TE_MULTILINE |
                                                  wx.TE_READONLY |
                                                  wx.SUNKEN_BORDER)
                                         )

            ##Create a sizer to manage the Canvas and message window
            MainSizer = wx.BoxSizer(wx.VERTICAL)
            MainSizer.Add(NC, 4, wx.EXPAND)
            MainSizer.Add(self.sizer2, 0, wx.EXPAND)
            MainSizer.Add(self.MsgWindow, 1, wx.EXPAND | wx.ALL, 5)

            self.SetSizer(MainSizer)
            self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)

            self.Canvas.Bind(FloatCanvas.EVT_MOTION, self.OnMove)
            self.Canvas.Bind(FloatCanvas.EVT_MOUSEWHEEL, self.OnWheel)

            self.EventsAreBound = False

            ## getting all the colors for random objects
            wx.lib.colourdb.updateColourDB()
            self.colors = wx.lib.colourdb.getColourList()


            return None

        def Log(self, text):
            self.MsgWindow.AppendText(text)
            if not text[-1] == "\n":
                self.MsgWindow.AppendText("\n")


        def BindAllMouseEvents(self):
            if not self.EventsAreBound:
                ## Here is how you catch FloatCanvas mouse events
                self.Canvas.Bind(FloatCanvas.EVT_LEFT_DOWN, self.OnLeftDown)
                self.Canvas.Bind(FloatCanvas.EVT_LEFT_UP, self.OnLeftUp)
                self.Canvas.Bind(FloatCanvas.EVT_LEFT_DCLICK, self.OnLeftDouble)

                self.Canvas.Bind(FloatCanvas.EVT_MIDDLE_DOWN, self.OnMiddleDown)
                self.Canvas.Bind(FloatCanvas.EVT_MIDDLE_UP, self.OnMiddleUp)
                self.Canvas.Bind(FloatCanvas.EVT_MIDDLE_DCLICK, self.OnMiddleDouble)

                self.Canvas.Bind(FloatCanvas.EVT_RIGHT_DOWN, self.OnRightDown)
                self.Canvas.Bind(FloatCanvas.EVT_RIGHT_UP, self.OnRightUp)
                self.Canvas.Bind(FloatCanvas.EVT_RIGHT_DCLICK, self.OnRightDouble)

            self.EventsAreBound = True


        def UnBindAllMouseEvents(self):
            ## Here is how you unbind FloatCanvas mouse events
            self.Canvas.Unbind(FloatCanvas.EVT_LEFT_DOWN)
            self.Canvas.Unbind(FloatCanvas.EVT_LEFT_UP)
            self.Canvas.Unbind(FloatCanvas.EVT_LEFT_DCLICK)

            self.Canvas.Unbind(FloatCanvas.EVT_MIDDLE_DOWN)
            self.Canvas.Unbind(FloatCanvas.EVT_MIDDLE_UP)
            self.Canvas.Unbind(FloatCanvas.EVT_MIDDLE_DCLICK)

            self.Canvas.Unbind(FloatCanvas.EVT_RIGHT_DOWN)
            self.Canvas.Unbind(FloatCanvas.EVT_RIGHT_UP)
            self.Canvas.Unbind(FloatCanvas.EVT_RIGHT_DCLICK)

            self.EventsAreBound = False


        def PrintCoords(self,event):
            self.Log("coords are: %s"%(event.Coords,))
            self.Log("pixel coords are: %s\n"%(event.GetPosition(),))

        def OnOpen(self,e):
            """ Open a file"""
            dlg = wx.FileDialog(self, "Choose a file", "", "", "*.fcl", wx.OPEN)
            if dlg.ShowModal() == wx.ID_OK:
                self.filename = dlg.GetFilename()
                self.dirname = dlg.GetDirectory()
            self.filename = dlg.GetPath()
            print 'open a file', self.filename
            self.Clear()
            Model.rules = []
            Model.terms = []
            Model.decisions = []
            Model.inputs = []
            Model.outputs = []
            self.ReadRuleEngine()
            dlg.Destroy()

        def ShowFlcFile(self, evt):
            dlg = wx.FileDialog(self, "Choose an FLC file", "", "", "*.*", wx.OPEN)
            if dlg.ShowModal() == wx.ID_OK:
                self.filename = dlg.GetFilename()
                self.dirname = dlg.GetDirectory()
                self.Log("selected dir: " + dlg.GetDirectory() + ", file: " + dlg.GetFilename())

            f = open(dlg.GetDirectory() + '\\' + dlg.GetFilename(), "r")
            msg = f.read()
            f.close()

            dlg = wx.lib.dialogs.ScrolledMessageDialog(self, msg, "message test")
            dlg.ShowModal()

        def OnSavePNG(self, event=None):
            import os
            dlg = wx.FileDialog(
                self, message="Save file as ...", defaultDir=os.getcwd(),
                defaultFile="", wildcard="*.png", style=wx.SAVE
                )
            if dlg.ShowModal() == wx.ID_OK:
                path = dlg.GetPath()
                if not(path[-4:].lower() == ".png"):
                    path = path+".png"
                self.Canvas.SaveAsImage(path)

        def OnLeftDown(self, event):
            self.Log("LeftDown")
            self.PrintCoords(event)

        def OnLeftUp(self, event):
            self.Log("LeftUp")
            self.PrintCoords(event)

        def OnLeftDouble(self, event):
            self.Log("LeftDouble")
            self.PrintCoords(event)

        def OnMiddleDown(self, event):
            self.Log("MiddleDown")
            self.PrintCoords(event)

        def OnMiddleUp(self, event):
            self.Log("MiddleUp")
            self.PrintCoords(event)

        def OnMiddleDouble(self, event):
            self.Log("MiddleDouble")
            self.PrintCoords(event)

        def OnRightDown(self, event):
            self.Log("RightDown")
            self.PrintCoords(event)

        def OnRightUp(self, event):
            self.Log("RightUp")
            self.PrintCoords(event)

        def OnRightDouble(self, event):
            self.Log("RightDouble")
            self.PrintCoords(event)

        def OnWheel(self, event):
            self.Log("Mouse Wheel")
            self.PrintCoords(event)
            Rot = event.GetWheelRotation()
            Rot = Rot / abs(Rot) * 0.1
            if event.ControlDown(): # move left-right
                self.Canvas.MoveImage( (Rot, 0), "Panel" )
            else: # move up-down
                self.Canvas.MoveImage( (0, Rot), "Panel" )

        def OnMove(self, event):
            """
            Updates the status bar with the world coordinates
            """
            self.SetStatusText("%.2f, %.2f"%tuple(event.Coords))
            event.Skip()

        def OnAbout(self, event):
            dlg = wx.MessageDialog(self,
                                   "This is a program to create and handle rules \n"
                                   "using the fuzzy logic\n",
                                   "AIT",
                                   wx.OK | wx.ICON_INFORMATION)
            dlg.ShowModal()
            dlg.Destroy()

        def ZoomToFit(self,event):
            self.Canvas.ZoomToBB()

        def Clear(self,event = None):
            self.UnBindAllMouseEvents()
            self.Canvas.InitAll()
            self.Canvas.Draw()

        def OnQuit(self,event):
            self.Close(True)

        def OnCloseWindow(self, event):
            self.Destroy()

        def ShowFrame(self):
            Object = self.MovingObject
            Range = self.Range
            if  self.TimeStep < self.NumTimeSteps:
                x,y = Object.XY
                if x > Range[1] or x < Range[0]:
                    self.dx = -self.dx
                if y > Range[1] or y < Range[0]:
                    self.dy = -self.dy
                Object.Move( (self.dx,self.dy) )
                Object.Text.Move( (self.dx,self.dy))
                self.Canvas.Draw()
                self.TimeStep += 1
                wx.GetApp().Yield(True)
            else:
                self.Timer.Stop()


        def MoveMe(self, Object):
            self.MovingObject = Object
            Range = self.Range
            self.dx = random.uniform(Range[0]/4,Range[1]/4)
            self.dy = random.uniform(Range[0]/4,Range[1]/4)
            #import time
            #start = time.time()
            self.NumTimeSteps = 200
            self.TimeStep = 1
            self.Timer.Start(self.FrameDelay)
            #print "Did %i frames in %f seconds"%(N, (time.time() - start) )

        def AddRule(self,event):
            self.Canvas.ZoomToBB()

        def ReadRuleEngine(self, event=None):
            if self.filename != None:
                self.Log('Opened rule engine: ' + self.filename + "\n")
                f = open(self.filename, 'r')

                with f:
                    self.data = f.read()
                self.data = self.data.replace('\t','    ')

                self.Log('Opened definitions: ' + self.filename_def + "\n")
                fdef = open(self.filename_def, 'r')

                with fdef:
                    self.datadef = fdef.read()
                self.datadef = self.datadef.replace('\t','    ')

                # read input settings and values
                if 'EXPERIMENTBLOCK' in self.datadef:
                    experiment_block_begin_pos = self.datadef.find('EXPERIMENTBLOCK')
                    experiment_block_end_pos = self.datadef.find('END_EXPERIMENTBLOCK')
                    experiment_block = self.datadef[experiment_block_begin_pos:experiment_block_end_pos].replace(' ', '').replace('\n\n', '\n').split('\n')[1:-1]
                    print 'experiment block', experiment_block
                    Model.headers = experiment_block[0].split(';')
                    Model.exp_values = experiment_block[1::]

                # read positive decisions
                decision_pos = self.datadef.find('VAR_POSITIVE_DECISION')
                ruleblock_pos = self.datadef.find('EXPERIMENTBLOCK')
                decision_block = self.datadef[ decision_pos : ruleblock_pos : ]
                var_decisions_part = decision_block.replace(' ', '').replace('\n\n','\n').split('VAR_POSITIVE_DECISION')[1::]
                #print 'decision part: ', var_decisions_part
                for var_decisions in var_decisions_part[::2]:
                    v = var_decisions.replace('END_DECISION_VAR\n', '').replace('\n\n','\n').split('\n')
                    ##print 'decision: ', v, ', decision name: ', v[0]
                    allconditions = []
                    for condition in v[1::]:
                        if ':=' in condition:
                            eq_pos = condition.find(':=')
                            end_pos = condition.find(';')
                            d = []
                            print 'condition: ', condition
                            condition = condition.replace(' ', '')
                            condition_row = condition.split(':=')
                            print 'condition_row', condition_row
                            #print 'condition_row0', condition_row[0], 'condition_row1', condition_row[1]
                            if len(condition_row[0]) > 0:
                                print 'condition_row: ', condition_row
                                allconditions.append(condition_row)
                            print 'decision', v[0], 'allconditions', allconditions
                    Model.decisions.append(Decision(v[0], allconditions))

                # read defuzzify rules
                defuzzify_pos = self.data.find('DEFUZZIFY')
                end_defuzzify_pos = self.data.find('END_DEFUZZIFY')
                rules_block = self.data[ defuzzify_pos : end_defuzzify_pos : ]
                #print 'rules_block', rules_block
                first_break_pos = rules_block.find('\n')
                #print 'defuzzify_pos', defuzzify_pos, 'first_break_pos', first_break_pos
                defuzzifyRuleName = rules_block[len('DEFUZZIFY') : first_break_pos].replace(' ', '')
                var_rules_part = rules_block.replace(' ', '').replace('\n\n','\n').split('\n')[1::]
                print 'defuzzify rules part: ', var_rules_part
                for term in var_rules_part:
                    if 'TERM' in term:
                        term_name_pos = term.find('TERM')
                        eq_pos = term.find(':=')
                        end_pos = term.find(';')
                        term_name = term[term_name_pos + 4 : eq_pos]
                        d = []
                        d.extend([term[eq_pos + 2 : end_pos], None])
                        if (len(term_name) > 0):
                            print 'defuzzifyRuleName', defuzzifyRuleName, 'term_name', term_name, 'd: ', d
                            Model.terms.append(Term(defuzzifyRuleName, term_name, d))

                # read rules
                fuzzify_pos = self.data.find('FUZZIFY')
                defuzzify_pos = self.data.find('DEFUZZIFY')
                rules_block = self.data[ fuzzify_pos : defuzzify_pos : ]
                var_rules_part = rules_block.replace(' ', '').replace('\n\n','\n').split('FUZZIFY')[1::]
                #print 'rules part: ', var_rules_part
                for var_rules in var_rules_part[::2]:
                    v = var_rules.replace('END_FUZZIFY\n', '').replace('\n\n','\n').split('\n')
                    ##print 'rules: ', v, ', rule name: ', v[0]
                    for term in v[1::]:
                        #print 'term: ', term
                        term_name_pos = term.find('TERM')
                        eq_pos = term.find(':=')
                        end_pos = term.find(';')
                        range_pos = term.find('(')
                        term_name = term[term_name_pos + 4 : eq_pos]
                        d = []
                        if (range_pos > 0):
                            for row in term.split('(')[1:]:
                                #print 'row: ', row
                            	range_pair = row.replace(' ', '')
                                range_end_pos = range_pair.find(')')
                                range = range_pair[:range_end_pos].split(',')
                                #print 'range: ', range
                                d.extend([range[0], range[1]])
                        else:
                            d.extend([term[eq_pos + 2 : end_pos], None])

                        if (len(term_name) > 0):
                            #print 'd: ', d
                            Model.terms.append(Term(v[0], term_name, d))

                    var_inputs_part = self.data.split('VAR_INPUT')
                    var_inputs = var_inputs_part[1].replace(':','').split('END_VAR')
                    ##print 'var_inputs: ', var_inputs[0]

                    var_outputs_part = self.data.split('VAR_OUTPUT')
                    var_outputs = var_outputs_part[1].replace(':','').split('END_VAR')
                    ##print 'var_outputs: ', var_outputs[0]

                    # read inputs
                    input_names = var_inputs[0].split('\n')
                    for n in input_names:
                       x = n.replace(' ', '')
                       real_pos = x.find('REAL')
                       range_pos = x.find('RANGE(')
                       sep_pos = x.find('..')
                       end_pos = x.find(')')
                       if (real_pos > 0): # TODO save inputs and outputs only once
                           add = True
                           for inputObj in Model.inputs:
                              if inputObj.name == x[:real_pos]:
                                add = False
                                break
                           if add == True:
                                Model.inputs.append(Input(x[:real_pos], x[range_pos + 6:sep_pos], x[sep_pos + 2: end_pos], None)) #weight))

                    output_names = var_outputs[0].split('\n')
                    for n in output_names:
                       x = n.replace(' ', '')
                       real_pos = x.find('REAL')
                       range_pos = x.find('RANGE(')
                       sep_pos = x.find('..')
                       end_pos = x.find(')')
                       if (real_pos > 0):
                           add = True
                           for outputObj in Model.outputs:
                              if outputObj.name == x[:real_pos]:
                                add = False
                                break
                           if add == True:
                               Model.outputs.append(Output(x[:real_pos], x[range_pos + 6:sep_pos], x[sep_pos + 2: end_pos], 0.5))

                for n in input_names:
                    if len(n) > 0:
                        rule = n.replace(' ', '')
                        real_pos = rule.find('REAL')
                        rule_str = rule[:real_pos]
                        Model.rules.append(Rule(rule_str,INPUT_RULE));

                for n in output_names:
                    if len(n) > 0:
                        rule = n.replace(' ', '')
                        real_pos = rule.find('REAL')
                        rule_str = rule[:real_pos]
                        Model.rules.append(Rule(rule_str,OUTPUT_RULE));
                self.ShowRuleEngine()
            self.Canvas.ZoomToBB()

        def ShowRuleEngine(self, event=None):#, isRun=False):
            print 'ShowRuleEngine() isRun', Model.isRun
            wx.GetApp().Yield(True)

            self.UnBindAllMouseEvents()
            Canvas = self.Canvas
            Canvas.InitAll()

            w, h = WIDTH, HEIGHT
            dx = DX
            dy = DY
            x, y = X_START, Y_START
            FontSize = FONT_SIZE

            if self.filename != None:
                self.Log('Opened rule engine: ' + self.filename + "\n")
                #print Model.rules
                input_rules_count = 0;
                for n in Model.rules:
                    str = n.name
                    ##print 'str:',str,';'
                    if len(str) > 0 and n.type == INPUT_RULE:
                        #print 'n: ', n
                        rule_str = n.name.replace('_',' ')
                        x = X_START
                        y += dy
                        color = "RED"
                        R = Canvas.AddRectangle((x, y), (w, h), LineWidth = 2, FillColor = color)
                        L1 = Canvas.AddLine(( (x-dx, y+h/2), (x, y+h/2) ), LineWidth = LINE_WIDTH, LineColor = "Green") # line before rule
                        L2 = Canvas.AddLine(( (x+w, y+h/2), (x+w+dx*2, y+h/2) ), LineWidth = LINE_WIDTH, LineColor = "Green") # line after rule
                        R.Name = rule_str
                        R.Bind(FloatCanvas.EVT_FC_RIGHT_DOWN, self.RectGotHitRight)
                        R.Bind(FloatCanvas.EVT_FC_LEFT_DOWN, self.RectGotHitLeft)
                        #Canvas.AddText("L and R Click", (x, y), Size = FontSize, Position = "bl")
                        Canvas.AddText(rule_str, (x, y+h), Size = FontSize, Position = "tl")
                        if Model.isRun == True:
                            #print 'isRun', Model.isRun
                            inputValues = Model.exp_values[0].split(';')
                            inputValue = inputValues[input_rules_count]
                            Canvas.AddText(inputValue, (x-dx, y+h/2+10), Size = FontSize, Position = "tl", Color = "White")
                        input_rules_count = input_rules_count+1;

                L3 = Canvas.AddLine(( (x+w+dx*2, y+h/2), (x+w+dx*2, Y_START+dy+h/2) ), LineWidth = LINE_WIDTH, LineColor = "Green") # vertical line
                # arrow before output rule
                L4 = Canvas.AddLine(( (x+w+dx*2,(y+h+dy+Y_START)/2), (x+2*w, (y+h+dy+Y_START)/2) ), LineWidth = LINE_WIDTH, LineColor = "Green") # line after rule
                #print 'y: ', y
                for n in Model.rules:
                    str = n.name
                    if len(str) > 0 and n.type == OUTPUT_RULE:
                        #print 'n: ', n
                        rule_str = n.name.replace('_',' ')
                        x = 2*w
                        y = HEIGHT+dy*(input_rules_count+1)/2
                        color = "CYAN"
                        #print 'y2: ', y
                        R = Canvas.AddRectangle((x, y), (w, h), LineWidth = 2, FillColor = color)
                        R.Name = rule_str
                        R.Bind(FloatCanvas.EVT_FC_RIGHT_DOWN, self.RectGotHitRight)
                        R.Bind(FloatCanvas.EVT_FC_LEFT_DOWN, self.RectGotHitLeft)
                        Canvas.AddText(rule_str, (x, y+h), Size = FontSize, Position = "tl")
                        if Model.isRun == True:
                            outputValue = Model.outputs[0]
                            print 'outputValue', outputValue
                            res = repr(outputValue)
                            Canvas.AddText(res, (x+w+2*dx-10, y+h/2+10), Size = FontSize, Position = "tl", Color = "White")
                # arrow after output rule
                Canvas.AddArrow((x+w,y+h/2),Length = 2*dx, Direction = 90,LineWidth = LINE_WIDTH, LineColor = "Green",  ArrowHeadAngle = 50)
            self.Canvas.ZoomToBB()
            Model.isRun = False

        def RectMoveLeft(self,Object):
            self.MoveRects("left")

        def RectMoveRight(self,Object):
            self.MoveRects("right")

        def RectMoveUp(self,Object):
            self.MoveRects("up")

        def RectMoveDown(self,Object):
            self.MoveRects("down")

        def MoveRects(self, Dir):
            for Object in self.MovingRects:
                X,Y = Object.XY
                if Dir == "left": X -= 10
                elif Dir == "right": X += 10
                elif Dir == "up": Y += 10
                elif Dir == "down": Y -= 10
                Object.SetPoint((X,Y))
            self.Canvas.Draw()

        def PointSetGotHit(self, Object):
            self.Log(Object.Name + " Got Hit\n")

        def RectGotHit(self, Object):
            self.Log(Object.Name + " Got Hit\n")

        def RectGotHitRight(self, Object):
            self.Log(Object.Name + " Got Hit With Right\n")

        def RectGotHitLeft(self, Object):
            self.Log(Object.Name + " Got Hit with Left\n")

            dlg = RuleEditDialog(self, -1, Object.Name)
            dlg.SetTitle(Object.Name)
            if dlg.ShowModal() == wx.ID_OK:
                rowsCount = len(dlg.ranges)
                print 'ok: ', rowsCount
                #origTerms = range(rowsCount)
                termIdx = 0
                for term in Model.terms:
                    if term.rule == Object.Name.replace(' ', '_'):
                        #origTerms[termIdx] = term.name
                        curTerm = dlg.terms[termIdx].GetValue()
                        if term.name != curTerm:
                            term.name = curTerm
                        termIdx = termIdx + 1

                for row in range(rowsCount):
                    termText = dlg.terms[row].GetValue()
                    removeFlag = dlg.removeFlags[row].GetValue()
                    positiveFlag = dlg.positiveFlags[row].GetValue()
                    print 'removeFlag: ', removeFlag
                    print 'positiveFlag: ', positiveFlag
                    if removeFlag == True:
                        resTerm = None
                        for term in Model.terms:
                            if term.rule == Object.Name.replace(' ', '_') and termText == term.name:
                                resTerm = term
                                break
                        if resTerm is not None:
                            Model.terms.remove(resTerm)
                    else:
                        range1 = dlg.ranges[0][0].GetValue()
                        self.Log('range00: ' + range1)

                        d = []
                        if (len(dlg.ranges[row]) > 1):
                            for field in dlg.ranges[row]:
                                print 'field: ', field.GetValue()
                                d.extend([field.GetValue()])
                        else:
                            d.extend([dlg.ranges[row][0], None])

                        print 'd: ', d
                        for term in Model.terms:
                            if term.rule == Object.Name.replace(' ', '_') and termText == term.name:
                                term.range_dict = d
            dlg.Destroy()

        def RectMouseOver(self, Object):
            self.Log("Mouse entered: " +  Object.Name)

        def RectMouseLeave(self, Object):
            self.Log("Mouse left " +  Object.Name)

        def binding2(self, event):
            self.Log("I'm the TextBox")

        def SelectPointHit(self, Point):
            self.Log("Point Num: %i Hit"%Point.VerticeNum)
            self.SelectedPoint = Point

        def OnCmdButton(self,event):
            self.Log("Click on button with Id %d\n" %event.GetId())
            if event.GetId() == ADD_RULE_ID:
                dlg = wx.TextEntryDialog(
                    self, 'Rule name',
                    'Add Rule', 'Python')

                dlg.SetValue("New rule")

                if dlg.ShowModal() == wx.ID_OK:
                    self.Log('You entered: %s\n' % dlg.GetValue())
                    Model.rules.append(Rule(dlg.GetValue(),INPUT_RULE));
                    for i in range(TERM_NUMBER):
                        d = ['0'] * RANGE_NUMBER
                        ruleName = dlg.GetValue().replace(" ", "_")
                        print 'empty terms: ', d, ' for rule: ', ruleName
                        Model.terms.append(Term(ruleName, 'Term' + str(i), d))

                dlg.Destroy()
                self.ShowRuleEngine()

            elif event.GetId() == REMOVE_RULE_ID:
                lst = []
                for n in Model.rules:
                    if len(n.name) > 0 and n.type == INPUT_RULE:
                        lst.append(n.name)

                dlg = wx.MultiChoiceDialog( self,
                                           "Select rules to delete from\nthis list",
                                           "wx.MultiChoiceDialog", lst)

                if (dlg.ShowModal() == wx.ID_OK):
                    selections = dlg.GetSelections()
                    strings = [lst[x] for x in selections]
                    self.Log("Selections: %s -> %s\n" % (selections, strings))
                    for n in Model.rules:
                        if n.name in strings:
                            Model.rules.remove(n)

                dlg.Destroy()
                self.ShowRuleEngine()

            elif event.GetId() == EXPORT_ID:
                dlg = wx.FileDialog(self, "Choose an FCL import file for rule engine", "", "import.fcl", "*.fcl", wx.OPEN)
                if dlg.ShowModal() == wx.ID_OK:
                    self.path = dlg.GetPath()
                    self.Log("selected import path: " + dlg.GetPath())

                f = open(dlg.GetPath(),'w')
                f.write('FUNCTION_BLOCK fb\n') # name is important for standard and pyfuzzy
                f.write('\n')

                f.write('VAR_INPUT\n')
                for i in Model.inputs:
                    f.write('\t' + i.name + ': REAL; (* RANGE(' + i.min_range + ' .. ' + i.max_range + ') *)\n')
                f.write('END_VAR\n\n')

                f.write('VAR_OUTPUT\n')
                for i in Model.outputs:
                    f.write('\t' + i.name + ': REAL; (* RANGE(' + i.min_range + ' .. ' + i.max_range + ') *)\n')
                f.write('END_VAR\n\n')

                outputFileName = ''
                for n in Model.rules:
                    if len(n.name) > 0 and n.type == OUTPUT_RULE:
                        outputFileName = n.name
                        break

                positiveDecisionTerm = ''
                negativeDecisionTerm = ''
                for n in Model.rules:
                    if len(n.name) > 0 and n.type == INPUT_RULE:
                        f.write('\n')
                        f.write('FUZZIFY\t' + n.name + '\n')
                        print 'fuzzify', n.name
                        for term in Model.terms:
                            if term.rule == n.name.replace(' ', '_'):
                                f.write('\tTERM\t' + term.name + '\t:=\t')
##                                print 'output file name', outputFileName, 'term rule', term.rule, 'term.name', term.name
                                if len(term.range_dict) > 2:
                                    res = ''
                                    for number, val in enumerate(term.range_dict):
                                        if number % 2 != 0:
                                            res = res + ', ' + val + ') '
                                        else:
                                            res = res + '(' +  val
                                    f.write(res + ' ;\n')
                                else:
                                    f.write(term.range_dict[0] + ' ;\n')
                        f.write('END_FUZZIFY\n')

                for n in Model.rules:
                    if len(n.name) > 0 and n.type == OUTPUT_RULE:
                        f.write('\n')
                        f.write('DEFUZZIFY\t' + n.name + '\n')
                        print 'defuzzify', n.name
                        for term in Model.terms:
                            if term.rule == n.name.replace(' ', '_'):
                                f.write('\tTERM\t' + term.name + '\t:=\t')
                                print 'output file name', outputFileName, 'term rule', term.rule, 'term.name', term.name
                                if outputFileName == term.rule and 'Not' not in term.name:
                                    positiveDecisionTerm = term.name
                                if outputFileName == term.rule and 'Not' in term.name:
                                    negativeDecisionTerm = term.name
                                if len(term.range_dict) > 2:
                                    res = ''
                                    for number, val in enumerate(term.range_dict):
                                        if number % 2 != 0:
                                            res = res + ', ' + val + ') '
                                        else:
                                            res = res + '(' +  val
                                    f.write(res + ' ;\n')
                                else:
                                    f.write(term.range_dict[0] + ' ;\n')
                        f.write('\tACCU : MAX;\n')
                        f.write('\tMETHOD : COGS;\n')
                        f.write('\tDEFAULT := 0;\n')
                        f.write('END_DEFUZZIFY\n')
                        f.write('\n')

                print 'export decisions size: ', len(Model.decisions)
                decisions = []
                curDecisionStr = ''
                for decision in Model.decisions:
                    print len(decision.condition)
                    for curCondition in decision.condition:
                        print 'condition: ', curCondition
                        curDecisionStr = curDecisionStr + curCondition[0] + ' IS ' + curCondition[1] + ' AND '

                f.write('RULEBLOCK first\n')
                f.write('\n')
                f.write('AND : MIN;\n')

                termList = range(len(Model.terms))
                for i, term in enumerate(Model.terms):
                    termList[i] = term.name
                import itertools
                allterms = []
                for n in Model.rules:
                    if len(n.name) > 0 and n.type == INPUT_RULE:
                        ruleterms = []
                        for term in Model.terms:
                            if term.rule == n.name.replace(' ', '_'):
                                ruleterms.append(term.rule + ' IS ' + term.name)
                        allterms.append(ruleterms)
                print 'dec', positiveDecisionTerm, negativeDecisionTerm
                for idx, element in enumerate(itertools.product(*allterms)):
                    ruleStr = 'RULE ' + str(idx) + ': IF ' + str(element)[1:-1].replace(',', ' AND').replace('\'','') + ' THEN ' + outputFileName
                    ###print 'ruleStr', ruleStr, 'curDecisionStr', curDecisionStr[:-4]
                    if curDecisionStr[:-4] in ruleStr:
                        ###print 'positiveDecisionTerm'
                        ruleStr = ruleStr + ' IS ' + positiveDecisionTerm + ';\n'
                    else:
                        ruleStr = ruleStr + ' IS ' + negativeDecisionTerm + ';\n'
                    f.write(ruleStr)
                f.write('END_RULEBLOCK\n')
                f.write('END_FUNCTION_BLOCK\n')
                f.close()

                dlg.Destroy()
                self.ShowRuleEngine()

            elif event.GetId() == RUN_ID:
                print 'headers', Model.headers
                print 'experiment values', Model.exp_values
                import fuzzy.storage.fcl.Reader
                system = fuzzy.storage.fcl.Reader.Reader().load_from_file(self.filename)
                # preallocate input and output values
                values = Model.exp_values[0].split(';')
                my_input = {}
                my_output = {}
                for idx, header in enumerate(Model.headers):
                    if len(header) > 0:
                        my_input[header] = int(values[idx])
                print 'my_input', my_input
                for n in Model.rules:
                    if len(n.name) > 0 and n.type == OUTPUT_RULE:
                        print 'rule name', n.name, 'n.type', n.type
                        my_output[n.name] = 0
                print 'my_output', my_output

                # calculate
                system.calculate(my_input, my_output)

                # now use outputs
                print my_output
                Model.outputs = []
                Model.outputs.extend(my_output.values())
                Model.isRun = True
                self.ShowRuleEngine()#True)

            if event.GetId() == ID_PLOT:
                self.showPlot("Plot")
                dlg.Destroy()
                self.ShowRuleEngine()

    return DrawFrame

#---------------------------------------------------------------------------

if __name__ == "__main__":

    import wx

    # check options:
    import sys, getopt
    optlist, args = getopt.getopt(sys.argv[1:],'l',["all",
                                                    "hit",
                                                    "hitf",
                                                    "hide"])

    if not haveNumpy:
        raise ImportError(errorText)
    StartUpDemo = "hit" # the default
    if optlist:
        StartUpDemo = optlist[0][0][2:]


    class DemoApp(wx.App):
        """
        How the tool works:

        Under the Draw menu, there are three options:

        *Clear: Clears the Canvas.

        """

        def __init__(self, *args, **kwargs):
            wx.App.__init__(self, *args, **kwargs)

        def OnInit(self):
            wx.InitAllImageHandlers()
            DrawFrame = BuildDrawFrame()
            frame = DrawFrame(None, -1, "Expert System Tool",wx.DefaultPosition,(900,700))

            self.SetTopWindow(frame)
            frame.Show()

            if StartUpDemo == "text":
                frame.TestText()
            elif StartUpDemo == "bitmap":
                frame.TestBitmap()
            elif StartUpDemo == "hit":
                frame.ReadRuleEngine()
            elif StartUpDemo == "hide":
                frame.HideTest()

            return True

    app = DemoApp(False)# put in True if you want output to go to it's own window.
    app.MainLoop()

else:
    # It's not running stand-alone, set up for wxPython demo.
    # don't  neeed wxversion here.
    import wx
    if not haveNumpy:
        ## TestPanel and runTest used for integration into wxPython Demo
        class TestPanel(wx.Panel):
            def __init__(self, parent, log):
                self.log = log
                wx.Panel.__init__(self, parent, -1)

                from wx.lib.floatcanvas.ScreenShot import getScreenShotBitmap

                note1 = wx.StaticText(self, -1, errorText)
                note2 = wx.StaticText(self, -1, "This is what the Expert System Tool can look like:")
                S = wx.BoxSizer(wx.VERTICAL)
                S.Add((10, 10), 1)
                S.Add(note1, 0, wx.ALIGN_CENTER)
                S.Add(note2, 0, wx.ALIGN_CENTER | wx.BOTTOM, 4)
                S.Add(wx.StaticBitmap(self,-1,getScreenShotBitmap()),0,wx.ALIGN_CENTER)
                S.Add((10, 10), 1)
                self.SetSizer(S)
                self.Layout()

    else:
        ## TestPanel and runTest used for integration into wxPython Demo
        class TestPanel(wx.Panel):
            def __init__(self, parent, log):
                self.log = log
                wx.Panel.__init__(self, parent, -1)
                note1 = wx.StaticText(self, -1, "The Expert System Tool needs")
                note2 = wx.StaticText(self, -1, "a separate frame")
                b = wx.Button(self, -1, "Open Demo Frame Now")
                b.Bind(wx.EVT_BUTTON, self.OnButton)

                S = wx.BoxSizer(wx.VERTICAL)
                S.Add((10, 10), 1)
                S.Add(note1, 0, wx.ALIGN_CENTER)
                S.Add(note2, 0, wx.ALIGN_CENTER | wx.BOTTOM, 5)
                S.Add(b, 0, wx.ALIGN_CENTER | wx.ALL, 5)
                S.Add((10, 10), 1)
                self.SetSizer(S)
                self.Layout()

            def OnButton(self, evt):
                DrawFrame = BuildDrawFrame()
                frame = DrawFrame(None, -1, "Expert System Tool",wx.DefaultPosition,(500,500))

                frame.Show()
                frame.ReadRuleEngine()

    def runTest(frame, nb, log):
        win = TestPanel(nb, log)
        return win

    # import to get the doc
    from wx.lib import floatcanvas
    overview = floatcanvas.__doc__

